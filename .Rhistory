shiny::runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
q<- seq(2,30, by=2)
sapply(q, f(x) { x*0.2})
sapply(q, f(x) x*0.2)
sapply(q, function(x) x*0.2)
q
df <- data.frame(q, sapply(q, function(x) x*0.2))
names(df) <- c(q,transfers)
names(df) <- c('q','transfers')
df
df['utility'] <- (1-exp(-0.1*df$q))/0.1 - df$transfers
df
calculateUtility <- function(alpha, theta) {
q <- seq(2, 30, by=2)
df <- data.frame(q, sapply(q, function(x) theta * x))
names(df) <- c('q','transfers')
df['utility'] <- (1-exp(-alpha*df$q))/alpha - df$transfers
df
}
calculateUtility(0.1, 0.1)
calculateUtility <- function(q, alpha, theta) {
df <- data.frame(q, sapply(q, function(x) theta * x))
names(df) <- c('q','transfers')
df['utility'] <- (1-exp(-alpha*df$q))/alpha - df$transfers
df
}
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
install.packages('rsconnect')
runApp('principal_agent')
shiny::runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp('principal_agent')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp('principal_agent')
runApp('principal_agent')
dfc <- icalcMultipleUtility(qVec, alpha, theta1, theta2, propEfficient)
#
# This is the server logic of a Shiny web application.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
library(ggplot2)
# library(Cairo)   # For nicer ggplot2 output when deployed on Linux
library(reshape2)
library(shiny)
#
# Function names beginning with "i" are specifically for the incomplete
# information case.
#
# The raw utility of q widgets for a principal with an exponential utility
# and alpha preference.
expUtility <- function(alpha, q) {
(1-exp(-alpha*q))/alpha
}
# Solves the optimal quantity under full information.
# Derivative of utility with respect to q: alpha * exp(-alpha * q) / alpha
# Derivative of cost with respect to q: theta
# Set these equal and solve for q.
# exp(-alpha * q) = theta
# -alpha * q = log(theta)
# q = - log(theta) / alpha
# Note that in R, "log" is the natural log.
solveQ <- function(alpha, theta) {
-log(theta) / alpha
}
isolveAdjustment <- function(thetaEfficient, thetaInefficient, propEfficient) {
thetaDiff = thetaInefficient - thetaEfficient
propEfficient/(1-propEfficient) * thetaDiff
}
# Solves for q of the inefficient agent under incomplete information, where
# two possible thetas are known and the proportion of efficient agents.
# propEfficient must be in [0, 1).
# thetaInefficient > thetaEfficient
# TEST: isolveQInefficient(0.1, 0.1, 0.2, 0.5) == 12.04 (roughly)
# # where q-SB = -ln( v/(1-v) (theta- -theta_) + theta- ) / alpha
# (sing eq. 2.29 and substituting that S' = exp(alpha * q-SB) and solving for q-SB)
isolveQInefficient <- function(alpha, thetaEfficient, thetaInefficient,
propEfficient) {
adj <- isolveAdjustment(thetaEfficient, thetaInefficient, propEfficient)
-log(adj + thetaInefficient) / alpha
}
isolveTEfficient <- function(alpha, thetaEfficient, thetaInefficient,
propEfficient) {
qInefficient <- isolveQInefficient(alpha, thetaEfficient, thetaInefficient,
propEfficient)
thetaDiff = thetaInefficient - thetaEfficient
thetaEfficient * solveQ(alpha, thetaEfficient) + thetaDiff * qInefficient
}
# Use qVec as quantities, then calculate a column vector
# of raw utility. Then for each theta in the thetaList, generate a transfer
# and net utility column.
calcMultipleUtility <- function(qVec, alpha, thetaVec) {
df <- data.frame(qVec, sapply(qVec, function(x) expUtility(alpha, x)))
names(df) <- c('quantity','utility')
for (i in seq(length(thetaVec))) {
df[paste0('transfer', i)] <- thetaVec[i] * df['quantity']
df[paste0('net_utility_with_agent', i)] <- df['utility'] - df[paste0('transfer', i)]
}
df
}
# The principal's utility.
# See the reduced program P' on p. 42 of Laffont and Martimort 2002.
icalcUtility <- function(alpha, q1, q2, thetaEfficient, thetaInefficient,
propEfficient) {
propEfficient*(expUtility(alpha, q1) - q1*thetaEfficient) +
(1-propEfficient)*(expUtility(alpha, q2) - q2*thetaInefficient) -
propEfficient * (thetaInefficient - thetaEfficient) * q2
}
# Example: icalcMultipleUtility(seq(0, 30, by=1), 0.1, 0.1, 0.2, 0.5)
icalcMultipleUtility <- function(qVec, alpha, thetaEfficient, thetaInefficient,
propEfficient) {
# TODO(jean): The transfer to agent 1 (efficient)
# is greater than in the calculation below (greater than q1 * theta1).
df1 <- calcMultipleUtility(qVec, alpha, c(thetaEfficient))
names(df1) <- c('q1', 'u1', 'transfer1', 'utility1')
df2 <- calcMultipleUtility(qVec, alpha, c(thetaInefficient))
names(df2) <- c('q2', 'u2','transfer2', 'utility2')
dfc <- merge(df1, df2)
dfc['net_utility'] <- propEfficient*(dfc['utility1']) +
(1-propEfficient)*dfc['utility2'] -
propEfficient * (thetaInefficient - thetaEfficient) * dfc['q2']
dfc
}
# Example: createUtilityPlot(seq(0, 30, by=1), 0.1, 0.1, 0.2)
createUtilityPlot <- function(qVec, alpha, theta1, theta2) {
dfWide <- calcMultipleUtility(qVec, alpha, c(theta1, theta2))
# colnames(dfWide)[which(names(dfWide) == "net_utility_with_agent1")] <- "net_utility_with_efficient_agent"
# colnames(dfWide)[which(names(dfWide) == "net_utility_with_agent2")] <- "net_utility_with_inefficient_agent"
dfLong <- melt(dfWide, id=c("quantity"),
measure=c("utility", "net_utility_with_agent1", "net_utility_with_agent2"))
colnames(dfLong) <-c("quantity", "type", "utility")
p <- ggplot(dfLong, aes(x=quantity, y=utility, colour=type)) + geom_path()
q1 <- solveQ(alpha, theta1)
u1 <- expUtility(alpha, q1) - q1 * theta1
p <- p + geom_label(label="max", aes(x=q1, y=u1), colour="green")
q2 <- solveQ(alpha, theta2)
u2 <- expUtility(alpha, q2) - q2 * theta2
p <- p + geom_label(label="max", aes(x=q2, y=u2), colour="blue")
p
}
icreateUtilityPlot <- function(qVec, alpha, theta1, theta2, propEfficient) {
dfc <- icalcMultipleUtility(qVec, alpha, theta1, theta2, propEfficient)
dfcLong <- melt(dfc, id=c("q1", "q2"), measure=c("net_utility"))
#colnames(dfcLong) <-c("q1", "q2", "net_utility")
p <- ggplot(dfcLong, aes(x=q1, y=value, colour=q2, group=q2)) + geom_line()
utilFunc <- function(q1, q2) {icalcUtility(alpha, q1, q2, theta1, theta2,
propEfficient)}
# Below create a "legend" with a label directly on each line.  It's easier
# than looking at different shades of blue.
# The code below is hard-coded for what I know I passed in for qVec.
p <- p + geom_label(label="q2=0", aes(x=qVec[1], y=utilFunc(qVec[1], 0)))
p <- p + geom_label(label="q2=5", aes(x=qVec[2], y=utilFunc(qVec[2], 5)))
p <- p + geom_label(label="q2=10", aes(x=qVec[3], y=utilFunc(qVec[3],10)))
p <- p + geom_label(label="q2=15", aes(x=qVec[4], y=utilFunc(qVec[4], 15)))
p <- p + geom_label(label="q2=20", aes(x=qVec[5], y=utilFunc(qVec[5], 20)))
p <- p + geom_label(label="q2=25", aes(x=qVec[6], y=utilFunc(qVec[6], 25)))
p <- p + geom_label(label="q2=30", aes(x=qVec[7], y=utilFunc(qVec[7], 30)))
# Now add the label for spot that maximizes the principal's utility.
q1Max <- solveQ(alpha, theta1)
# TODO(jean): The function below returns q2 of 12, utility 5.64
# But a q2 of 15 does better, with a utility of 5.73.
q2Max <- isolveQInefficient(alpha, theta1, theta2, propEfficient)
uMax <- utilFunc(q1Max, q2Max)
labelMax <- paste0("max (q2=", format(round(q2Max, 2), nsmall = 2), ")")
p <- p + geom_label(label=labelMax, aes(x=q1Max, y=uMax),
colour="red")
p
}
dfc <- icalcMultipleUtility(seq(4), 0.1, 0.1, 0.2, 0.5)
dfcLong <- melt(dfc, id=c("q1", "q2"), measure=c("net_utility"))
dfcLong
head(dfc)
#
# This is the server logic of a Shiny web application.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
library(ggplot2)
# library(Cairo)   # For nicer ggplot2 output when deployed on Linux
library(reshape2)
library(shiny)
#
# Function names beginning with "i" are specifically for the incomplete
# information case.
#
# The raw utility of q widgets for a principal with an exponential utility
# and alpha preference.
expUtility <- function(alpha, q) {
(1-exp(-alpha*q))/alpha
}
# Solves the optimal quantity under full information.
# Derivative of utility with respect to q: alpha * exp(-alpha * q) / alpha
# Derivative of cost with respect to q: theta
# Set these equal and solve for q.
# exp(-alpha * q) = theta
# -alpha * q = log(theta)
# q = - log(theta) / alpha
# Note that in R, "log" is the natural log.
solveQ <- function(alpha, theta) {
-log(theta) / alpha
}
isolveAdjustment <- function(thetaEfficient, thetaInefficient, propEfficient) {
thetaDiff = thetaInefficient - thetaEfficient
propEfficient/(1-propEfficient) * thetaDiff
}
# Solves for q of the inefficient agent under incomplete information, where
# two possible thetas are known and the proportion of efficient agents.
# propEfficient must be in [0, 1).
# thetaInefficient > thetaEfficient
# TEST: isolveQInefficient(0.1, 0.1, 0.2, 0.5) == 12.04 (roughly)
# # where q-SB = -ln( v/(1-v) (theta- -theta_) + theta- ) / alpha
# (sing eq. 2.29 and substituting that S' = exp(alpha * q-SB) and solving for q-SB)
isolveQInefficient <- function(alpha, thetaEfficient, thetaInefficient,
propEfficient) {
adj <- isolveAdjustment(thetaEfficient, thetaInefficient, propEfficient)
-log(adj + thetaInefficient) / alpha
}
isolveTEfficient <- function(alpha, thetaEfficient, thetaInefficient,
propEfficient) {
qInefficient <- isolveQInefficient(alpha, thetaEfficient, thetaInefficient,
propEfficient)
thetaDiff = thetaInefficient - thetaEfficient
thetaEfficient * solveQ(alpha, thetaEfficient) + thetaDiff * qInefficient
}
# Use qVec as quantities, then calculate a column vector
# of raw utility. Then for each theta in the thetaList, generate a transfer
# and net utility column.
calcMultipleUtility <- function(qVec, alpha, thetaVec) {
df <- data.frame(qVec, sapply(qVec, function(x) expUtility(alpha, x)))
names(df) <- c('quantity','utility')
for (i in seq(length(thetaVec))) {
df[paste0('transfer', i)] <- thetaVec[i] * df['quantity']
df[paste0('net_utility_with_agent', i)] <- df['utility'] - df[paste0('transfer', i)]
}
df
}
# The principal's utility.
# See the reduced program P' on p. 42 of Laffont and Martimort 2002.
icalcUtility <- function(alpha, q1, q2, thetaEfficient, thetaInefficient,
propEfficient) {
propEfficient*(expUtility(alpha, q1) - q1*thetaEfficient) +
(1-propEfficient)*(expUtility(alpha, q2) - q2*thetaInefficient) -
propEfficient * (thetaInefficient - thetaEfficient) * q2
}
# Example: icalcMultipleUtility(seq(0, 30, by=1), 0.1, 0.1, 0.2, 0.5)
icalcMultipleUtility <- function(qVec, alpha, thetaEfficient, thetaInefficient,
propEfficient) {
# TODO(jean): The transfer to agent 1 (efficient)
# is greater than in the calculation below (greater than q1 * theta1).
df1 <- calcMultipleUtility(qVec, alpha, c(thetaEfficient))
names(df1) <- c('q1', 'u1', 'transfer1', 'utility1')
df2 <- calcMultipleUtility(qVec, alpha, c(thetaInefficient))
names(df2) <- c('q2', 'u2','transfer2', 'utility2')
dfc <- merge(df1, df2)
dfc['net_utility'] <- propEfficient*(dfc['utility1']) +
(1-propEfficient)*dfc['utility2'] -
propEfficient * (thetaInefficient - thetaEfficient) * dfc['q2']
dfc
}
# Example: createUtilityPlot(seq(0, 30, by=1), 0.1, 0.1, 0.2)
createUtilityPlot <- function(qVec, alpha, theta1, theta2) {
dfWide <- calcMultipleUtility(qVec, alpha, c(theta1, theta2))
# colnames(dfWide)[which(names(dfWide) == "net_utility_with_agent1")] <- "net_utility_with_efficient_agent"
# colnames(dfWide)[which(names(dfWide) == "net_utility_with_agent2")] <- "net_utility_with_inefficient_agent"
dfLong <- melt(dfWide, id=c("quantity"),
measure=c("utility", "net_utility_with_agent1", "net_utility_with_agent2"))
colnames(dfLong) <-c("quantity", "type", "utility")
p <- ggplot(dfLong, aes(x=quantity, y=utility, colour=type)) + geom_path()
q1 <- solveQ(alpha, theta1)
u1 <- expUtility(alpha, q1) - q1 * theta1
p <- p + geom_label(label="max", aes(x=q1, y=u1), colour="green")
q2 <- solveQ(alpha, theta2)
u2 <- expUtility(alpha, q2) - q2 * theta2
p <- p + geom_label(label="max", aes(x=q2, y=u2), colour="blue")
p
}
icreateUtilityPlot <- function(qVec, alpha, theta1, theta2, propEfficient) {
dfc <- icalcMultipleUtility(qVec, alpha, theta1, theta2, propEfficient)
dfcLong <- melt(dfc, id=c("q1", "q2"), measure=c("net_utility"))
colnames(dfcLong) <-c("q1", "q2", "ignore", "net_utility")
p <- ggplot(dfcLong, aes(x=q1, y=net_utility, colour=q2, group=q2)) + geom_line()
utilFunc <- function(q1, q2) {icalcUtility(alpha, q1, q2, theta1, theta2,
propEfficient)}
# Below create a "legend" with a label directly on each line.  It's easier
# than looking at different shades of blue.
# The code below is hard-coded for what I know I passed in for qVec.
p <- p + geom_label(label="q2=0", aes(x=qVec[1], y=utilFunc(qVec[1], 0)))
p <- p + geom_label(label="q2=5", aes(x=qVec[2], y=utilFunc(qVec[2], 5)))
p <- p + geom_label(label="q2=10", aes(x=qVec[3], y=utilFunc(qVec[3],10)))
p <- p + geom_label(label="q2=15", aes(x=qVec[4], y=utilFunc(qVec[4], 15)))
p <- p + geom_label(label="q2=20", aes(x=qVec[5], y=utilFunc(qVec[5], 20)))
p <- p + geom_label(label="q2=25", aes(x=qVec[6], y=utilFunc(qVec[6], 25)))
p <- p + geom_label(label="q2=30", aes(x=qVec[7], y=utilFunc(qVec[7], 30)))
# Now add the label for spot that maximizes the principal's utility.
q1Max <- solveQ(alpha, theta1)
# TODO(jean): The function below returns q2 of 12, utility 5.64
# But a q2 of 15 does better, with a utility of 5.73.
q2Max <- isolveQInefficient(alpha, theta1, theta2, propEfficient)
uMax <- utilFunc(q1Max, q2Max)
labelMax <- paste0("max (q2=", format(round(q2Max, 2), nsmall = 2), ")")
p <- p + geom_label(label=labelMax, aes(x=q1Max, y=uMax),
colour="red")
p
}
dfc <- icreateUtilityPlot(seq(4), 0.1, 0.1, 0.2, 0.5)
dfc
icreateUtilityPlot(seq(0, 30, by=5), 0.1, 0.1, 0.2, 0.5)
runApp('principal_agent')
icreateUtilityPlot(seq(0, 30, by=5), 0.1, 0.1, 0.2, 0.5)
runApp('principal_agent')
runApp('principal_agent')
install.packages("cairo")
install.packages("Cairo")
library("Cairo")
update.packages()
